---
title: 'Database Troubleshooting'
metaTitle: 'Database Troubleshooting'
metaDescription: 'When your database goes down in the middle of the night, the most stressful part is not knowing why. This article guides you through the possible reasons your database might be down and what you can do to fix it.'
metaImage: '/social/meta-orms.png'
---

## Introduction

Database troubleshooting

## Data Volume Issues

As an application grows, the data volume for that app will most likely grow as well. A key consideration for both performance and database uptime is the volume of data being processed to furnish a given request. Inefficient queries written for the app when total data volume is small can turn into bottlenecks that can tank performance and cause outages when that data grows.

Large data volumes can have an impact at three locations:

- The database server
- The app server
- The client

### The Database Server

When a database query is made from the app server, the database server's responsibility is to retrieve the requested data and send it back to the app server. In doing so, the database server must first scan the retrieved data into its own memory. When data volumes are small, the process of scanning data into memory and forwarding it to the app server is trivial. However, if a very large amount of data is returned from the query, an underprovisioned database server can crumble under the load.

This scenario often arises when queries that were initially sufficient with small total database size are not properly optimized as the data size grows.

Consider a scenario where an application needs to display a list of contacts for a user. A typical database query to furnish this data likely selects data scoped to that user.

```sql
SELECT * from contacts WHERE userId = 123;
```

Depending on the needs of the application, the app server may not have anything further to do than to forward the results to the client. This query is unlikely to cause data volume problems.

However, consider what would happen if there was no `WHERE` clause in the above query.

```sql
SELECT * from contacts;
```

If, instead, the query asked for _all_ contacts in the database and the app server was then responsible for filtering the list based on `userId` before forwarding the results to the client, the difference in data volume could be astronomical.

With relatively small overall data volumes, this inadequate query might go undetected. As data volumes grow, performance degradations might become noticable but might not totally break the application. As this happens, however, the database server will be loaded beyond what it may be provisioned for. As data volumes continue to grow even further, a tipping point may be reached where the database server is no longer able to handle the load.

### The App Server

Much like the database server does not have unlimited capacity to process large volumes of data, the same is true for the app server. It's possible that you have more control over capacity and sizing for your app server than you do for your database server, but increasing capacity on the app server may be unnecessary.

A large volume of data returned from the database server will take time and resources to process on the app server. If the app server is responding to a request from a client applciation, long waits at the app server can be problematic. Many cloud hosting providers enforce a request timeout after several minutes have passed. Web browsers will automatically retry requests after several minutes of a request sitting in a "pending" state, putting further strain on the system.

### The Client

Client applications might be most susceptible to bottlenecks caused by large data volumes. Unlike the app server and database server where you may have the ability to increase capacity, client applications that run in the browser or on mobile devices are subject to limitations of the browser, operating system, or both.

Sending an inordinately large volume of data to a client application will cause delays in processing and can severely degrade responsiveness. Once a given data size has been reached, the browser may become completely unresponsive and ultimately crash.

If very large data volumes are forwarded all the way from the database to the client, performance degradations will be felt every step along the way. This trifecta will lead to long load times and possibly a perceived outage at any one of these points. Compounding the problem, troubleshooting where the bottleneck exists can become difficult.

### Data Size Remedies

The fix for performance degradations and outages caused by data volume issues is nearly always to limit the amount of data returned from the database server. Doing so will alleviate problems at the database server, the app server, and the client.

#### Scope Data with `WHERE` Clauses

In the ficticious query example above, the entire contacts table for a database was queried. This means the database server needs to scan the whole table into memory before filtering down to the desired results which can put tremendous load on the database server and app server.

Start by looking for queries that are casting too wide a net. Chances are that these queries are taking a long time to process at the database server. Looking at the logs for long-running queries can give indications of where this is happening. Instead of returning many results and then filtering through them with app code, construct your queries to return the subset of results that are truly needed. In SQL, use the `WHERE` clause to get specific about the data you actually require.

#### Paginate Data with `LIMIT` and `OFFSET`

If large volumes of data are truly required for client applications, it's advisable to introduce pagination.

Pagination is a design pattern which limits the total number of records to be queried and returned at a given time. If a user would like to see more records, they must request them explicitly.

This design pattern is most often implemented using the `LIMIT` and `OFFSET` clauses. By choosing to skip a certain number of records and also limiting the number of returned results, the client and app servers can acheieve a pagination experience.

The query for the first page might look like this:

```sql
SELECT * from contacts WHERE userId = 123 LIMIT 25 OFFSET 0;
```

The query for the second page would then just set the value of `LIMIT` to the `OFFSET` value to get the next "page".

```sql
SELECT * from contacts WHERE userId = 123 LIMIT 25 OFFSET 25;
```

## Breaking Code Changes

A suspected database outage might be traced back to recent breaking changes made to client or server code. In these cases, it is likely not the database itself that is experiencing an outage, but rather the code used to retrieve data, process it, and return it to the client may have broken.

Code changes that might cause interruptions generally fall into three categories:

- Database queries
- Server code
- Client code

### Database Queries

Changes to database queries, even if they are small, can impact an application. If using raw SQL, a query statement might have become invalid in a recent code change. If the query itself is still valid, it might have been changed to return results that are no longer processable by other parts of the application.

Inspect source control changes to look for recent changes to database access (SQL statements or ORM usage). Try to isolate queries that are related to specific areas of the application that are impacted.

If there are no indications of changes to database access, another possibility is that the database schema has changed but migrations have not been run. Look for any recent migrations that might still need to be applied to the production database.

### Client and Server Code

Code changes to app code in the client or the server, even if small, can have the potential of creating what looks like a database outage. There are many specific issues that could be at the root of the problem, but some examples include:

- the client might be calling a server endpoint that no longer exists
- a server endpoint has changed the validation rules for payloads or query parameters
- the server is trying to access properties from returned data that has become invalid from a recent schema change

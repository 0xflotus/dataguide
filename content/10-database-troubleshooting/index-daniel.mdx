---
title: 'Database Troubleshooting'
metaTitle: 'Database Troubleshooting'
metaDescription: 'When your database goes down in the middle of the night, the most stressful part is not knowing why. This article guides you through the possible reasons your database might be down and what you can do to fix it.'
metaImage: '/social/meta-orms.png'
---

## Check the application logs

If your database appears to be down, your application logs might give you insight into any problems accepting requests or connecting to the database. Because the application server handles both client requests and requests to the database, it usually logs errors if there are problems with the database.

### Is the application server handling connections successfully?

Application server frameworks usually come with a built-in logger. It's common practice to log that the server can accept connections once the server has started.

For example, take a look at this log line:

```no-lines
{"level":30,"time":1617808854673,"pid":96741,"hostname":"do-server-1","msg":"Server listening at http://0.0.0.0:8000"}
```

The log shows that the server started and accepts connections at port 8000. But it's not enough to determine if an error occurred since the server started.

The next step would be to look at the most recent logs and check the HTTP status code of the most recent requests to the server. Typically request logs will look as follows:

```no-lines
{"level":30,"time":1617809865718,"pid":97326,"hostname":"do-server-1","reqId":5,"req":{"method":"POST","url":"/graphql","hostname":"0.0.0.0:3000","remoteAddress":"127.0.0.1","remotePort":53540},"msg":"incoming request"}
{"level":30,"time":1617809865719,"pid":97326,"hostname":"do-server-1","reqId":5,"res":{"statusCode":200},"responseTime":1.1810400485992432,"msg":"request completed"}
```

Each incoming request log contains a timestamp, the URL, and other information about the request. The first log indicates a request coming in, while the second shows that the request succeeded with the HTTP status code 200.

### Were there any database errors recently?

Since you're trying to debug a problem relating to the database, you should specifically look for failed requests. You can find these by filtering for requests with a response status code of 5xx, e.g., 500, that indicate a server error. 

If you notice multiple requests with the 500 status code, look for the point at which these started and check for any other logged errors. 

If the database is down or the database's credentials are wrong, you can see that logged. For example:

```no-lines
Can't reach database server at `db-postgresql-563564.b.db.ondigitalocean.com`:`5432`
```

The log above indicates that your application server can't reach the database. In such cases, check the database URL in your application server.

### Database problems troubleshooting

Now that you know that your application server is running but is unable to reach the database, the next step would be to determine the reason. This is best approached by eliminating potential sources of the problem.

If you're using a managed service for your database, it's good to first check the status page of your cloud provider. Most cloud providers provide a way to check if their infrastructure is operational, e.g. [Digital Ocean](https://status.digitalocean.com/), [Google Cloud Platform](https://status.cloud.google.com/), and [AWS](https://status.aws.amazon.com/). 

Once you've ruled out any problems with the cloud platform, the next thing to check is the logs or status of your database instance. Most cloud platforms provide a way to view database logs in addition to some metrics such as throughput and query statistics.

## Networking issues

Network-related issues can cause your database to be unavailable or seem to be down. In a three-tier application consisting of the client tier, the application tier (the back end), and the data tier (the database), networking issues can arise between the three tiers. 

When your database appears to be down or unresponsive, some common networking related issues might cause this:

- VPC and firewall issues
- Latency and timeouts between the application and database

> Note: The recommendations below are based on assumptions that might not apply to your architecture. Hence it's recommended to understand the failure modes and their causes when debugging issues with your database. 

### VPCs

When provisioning cloud resources such as databases on cloud platforms, they are isolated within a virtual private cloud. A virtual private cloud (VPC) is a private cloud computing environment contained within a public cloud. In practical terms, the VPC serves as a private network for your application resources and is isolated from the public internet. If your database and application are not in the same VPC (or the same cloud), you typically need to configure the VPC's firewall rules to allow the application's IP access to the database.

### Firewall rules

When your application and database are deployed to different cloud platforms or different VPCs, the firewall needs to be configured to allow access from the application to the database. 

If your application's IP is dynamic, it can change at any time. When the application's IP changes, it might fail to connect to the database until the firewall has been updated to allow the new IP access. 

### Firewall rules remedies

It's generally recommended to deploy the application and database in the same VPC and the same region because the two will communicate over a private network and won't be prone to any bottlenecks that public networks might incur. However, if that isn't possible, there are several possible fixes. 

The first approach would be to use a dedicated IP for your application and add a firewall rule allowing access from the IP. This approach ensures that you don't need to update the firewall rules because the IP remains the same.

If using a dedicated IP is not feasible due to cloud platform limitations or the deployment approach, e.g., serverless, consider enabling access to the database via public networks. While this approach decreases the security of the database, it ensures that when the IP of the application changes your application won't experience any sudden downtime until you update firewall rules. Moreover, the database would still be protected by the authentication mechanism. 

### Database connections

In a three-tier architecture, most requests to the application involve sending queries to the database. In such situations, there are several scenarios relating to database connections that can cause the database to appear down.

### Latency and timeouts

When the geographical and network distance between the application and database is substantial, increased request latency and timeout errors can be a problem. In such scenarios, increasing the connection timeout to the database from your application might be necessary to avoid timeout errors. 

ORMs and query builders hold a pool of connections to the database. These connections usually have a connection timeout configuration that controls how long to wait before timing out when establishing a connection. 

It's recommended to set an initial baseline timeout value and load test the application to see how it performs. Based on the number of failed requests from the load test, you might want to adjust the timeout and try again until you're confident that timeouts are not the cause of the problem. If your connection timeout configuration is too low, you run the risk of these timeouts leading to failed requests.

### Exhausted connection limit

Another common challenge with connection-based databases like MySQL and Postgres is that you can quickly exhaust the database's connection limit. Connection-oriented databases impose a limit on the number of open connections to the database. 

When you deploy your application using the traditional long-running process model, you can multiplex many incoming requests on fewer DB connections in a pool. For example, a single server instance might be able to handle 100 concurrent HTTP requests with a pool of 20 DB connections.

On serverless functions, however, each function instance can only handle 1 HTTP request at a time. Because each incoming request requires at least one connection to the database, there is no way for you to multiplex database connections.

Given this, it's recommended to use the database connection limit and then distribute those between the server instances that connect to it in a way that doesn't exhaust the database's connection limit. For example, suppose your database has a connection limit of 20. If you have two instances of your application server, you would want to set each server instance's connection pool to a maximum of 10 connections. 

For serverless deployments, consider running an external connection pooler like PgBouncer â€“ an additional infrastructure component that holds connections to the database and multiplexes incoming database queries from the serverless functions.
